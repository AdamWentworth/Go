
--- File: hooks\useBootstrapVariants.ts ---
// src/features/variants/hooks/useBootstrapVariants.ts
import { useEffect } from 'react';
import { useVariantsStore } from '@/features/variants/store/useVariantsStore';

export function useBootstrapVariants() {
  useEffect(() => {
    // grab the “real” hydrate function off of the store
    const { hydrateFromCache } = useVariantsStore.getState();

    // fire‑and‑forget, swallow & log errors
    void hydrateFromCache().catch((err: unknown) => {
      console.error('[VariantsStore] Hydrate error:', err);
    });
  }, []); // ← run only once on mount
}


--- File: repositories\variantsRepository.ts ---
// src/features/variants/repositories/variantsRepository.ts
import type { PokemonVariant } from '@/types/pokemonVariants';
import type { PokedexLists } from '@/types/pokedex';
import {
  getAllFromDB,
  getAllPokedexListsFromDB,
} from '@/db/indexedDB';
import { loadVariants } from '../utils/loadVariants';

export interface VariantsRepository {
  loadCache(): Promise<{ variants: PokemonVariant[]; pokedexLists: PokedexLists }>;
  fetchFresh(): Promise<{ variants: PokemonVariant[]; pokedexLists: PokedexLists }>;
}

export const variantsRepository: VariantsRepository = {
  async loadCache() {
    const [variants, pokedexLists] = await Promise.all([
      getAllFromDB<PokemonVariant>('pokemonVariants'),
      getAllPokedexListsFromDB(),
    ]);
    return { variants, pokedexLists };
  },

  async fetchFresh() {
    const { variants, pokedexLists } = await loadVariants();
    return { variants, pokedexLists };
  },
};


--- File: store\useVariantsStore.ts ---
// src/features/variants/store/useVariantsStore.ts
import { create } from 'zustand';
import type { PokemonVariant } from '@/types/pokemonVariants';
import type { PokedexLists } from '@/types/pokedex';
import { variantsRepository } from '../repositories/variantsRepository';
import {
  VARIANTS_KEY,
  POKEDEX_LISTS_KEY,
  isCacheFresh,
  setCacheTimestamp,
} from '../utils/cache';

interface VariantsState {
  variants: PokemonVariant[];
  pokedexLists: PokedexLists;
  variantsLoading: boolean;
  isRefreshing: boolean;
  hydrateFromCache(): Promise<void>;
  refreshVariants(): Promise<void>;
}

export const useVariantsStore = create<VariantsState>((set, get) => ({
  variants: [],
  pokedexLists: {} as PokedexLists,
  variantsLoading: true,
  isRefreshing: false,

  async hydrateFromCache() {
    try {
      const { variants, pokedexLists } = await variantsRepository.loadCache();
      if (variants.length) {
        set({ variants, pokedexLists, variantsLoading: false });
      }

      // If either cache is stale, trigger a background refresh
      if (!isCacheFresh(VARIANTS_KEY) || !isCacheFresh(POKEDEX_LISTS_KEY)) {
        void get().refreshVariants();
      }
    } catch (error) {
      console.error('[VariantsStore] hydrateFromCache failed:', error);
      void get().refreshVariants();
    }
  },

  async refreshVariants() {
    if (get().isRefreshing) return;
    set({ isRefreshing: true });

    try {
      // Try serving fresh cache first
      if (isCacheFresh(VARIANTS_KEY) && isCacheFresh(POKEDEX_LISTS_KEY)) {
        const { variants, pokedexLists } = await variantsRepository.loadCache();
        if (variants.length) {
          set({ variants, pokedexLists, variantsLoading: false });
          return;
        }
      }

      // Otherwise fetch from network
      const { variants, pokedexLists } = await variantsRepository.fetchFresh();
      set({ variants, pokedexLists, variantsLoading: false });

      // Update cache timestamps
      setCacheTimestamp(VARIANTS_KEY);
      setCacheTimestamp(POKEDEX_LISTS_KEY);
    } catch (error) {
      console.error('[VariantsStore] refreshVariants failed:', error);

      // Fallback to whatever cache we have
      try {
        const { variants, pokedexLists } = await variantsRepository.loadCache();
        if (variants.length) {
          set({ variants, pokedexLists, variantsLoading: false });
        } else {
          set({ variantsLoading: false });
        }
      } catch (fallbackErr) {
        console.error('[VariantsStore] cache fallback failed:', fallbackErr);
        set({ variantsLoading: false });
      }
    } finally {
      set({ isRefreshing: false });
    }
  },
}));


--- File: utils\cache.ts ---
// src/features/variants/utils/cache.ts

// Central cache key definitions and TTL logic for the Variants feature
export const VARIANTS_KEY = 'variantsTimestamp';
export const POKEDEX_LISTS_KEY = 'pokedexListsTimestamp';

// Time-to-live for cache entries (in milliseconds)
export const CACHE_TTL_MS = 1000 * 60 * 60 * 24; // 24 hours

/**
 * Record the current timestamp under the given key.
 */
export function setCacheTimestamp(key: string): void {
  localStorage.setItem(key, Date.now().toString());
}

/**
 * Check if the timestamp stored under `key` is still within the TTL.
 * Returns `false` if no timestamp is found or if it is too old.
 */
export function isCacheFresh(key: string): boolean {
  const raw = localStorage.getItem(key);
  if (!raw) return false;
  const ts = Number(raw);
  if (Number.isNaN(ts)) return false;
  return Date.now() - ts < CACHE_TTL_MS;
}


--- File: utils\createPokemonVariants.ts ---
// createPokemonVariants.ts

import { determinePokemonKey } from '../../../utils/PokemonIDUtils';
import { matchFormsAndVariantType } from '../../../utils/formMatcher';
import { getDisplayName } from '../../../utils/displayName';

import type { BasePokemon } from '../../../types/pokemonBase';
import type { PokemonVariant, VariantKind } from '../../../types/pokemonVariants';
import type { Costume, MegaEvolution, Fusion, MaxForm, RaidBoss } from '../../../types/pokemonSubTypes';

// Utility for constructing type icons
const getTypeIcon = (typeName?: string) =>
  typeName ? `/images/types/${typeName.toLowerCase()}.png` : '';

const createPokemonVariants = (pokemons: BasePokemon[]): PokemonVariant[] => {
  const generateVariants = (pokemon: BasePokemon): PokemonVariant[] => {
    const variants: PokemonVariant[] = [];

    // Helper to add a variant and compute its pokemonKey
    const addVariant = (variant: PokemonVariant) => {
      variant.pokemonKey = determinePokemonKey(variant);
      variants.push(variant);
    };

    /* ---------- default variant ---------- */
    const defaultVariant: PokemonVariant = {
      ...pokemon,
      type_1_icon: pokemon.type_1_icon || '',
      type_2_icon: pokemon.type_2_icon || '',
      species_name: pokemon.name,
      currentImage: pokemon.image_url,
      variantType: 'default',
      pokemonKey: '',
    };
    defaultVariant.name = getDisplayName(defaultVariant);
    addVariant(defaultVariant);

    /* ---------- shiny variant ---------- */
    if (pokemon.shiny_available) {
      const shinyVariant: PokemonVariant = {
        ...defaultVariant,
        currentImage: pokemon.image_url_shiny,
        variantType: 'shiny',
      };
      shinyVariant.name = getDisplayName(shinyVariant);
      addVariant(shinyVariant);
    }

    /* ---------- shadow & shiny shadow variants ---------- */
    if (pokemon.date_shadow_available) {
      const shadowVariant: PokemonVariant = {
        ...defaultVariant,
        currentImage: pokemon.image_url_shadow || pokemon.image_url,
        variantType: 'shadow',
      };
      shadowVariant.name = getDisplayName(shadowVariant);
      addVariant(shadowVariant);

      if (pokemon.date_shiny_shadow_available) {
        const shinyShadowVariant: PokemonVariant = {
          ...defaultVariant,
          currentImage: pokemon.image_url_shiny_shadow || pokemon.image_url_shiny,
          variantType: 'shiny_shadow',
        };
        shinyShadowVariant.name = getDisplayName(shinyShadowVariant);
        addVariant(shinyShadowVariant);
      }
    }

    /* ---------- costume variants ---------- */
    pokemon.costumes?.forEach((c) => {
      const costume = c as Costume;

      const costumeVariant: PokemonVariant = {
        ...defaultVariant,
        currentImage: costume.image_url,
        variantType: `costume_${costume.costume_id}` as VariantKind,
      };
      costumeVariant.name = getDisplayName(costumeVariant);
      addVariant(costumeVariant);

      if (costume.shiny_available && costume.image_url_shiny) {
        const costumeShinyVariant: PokemonVariant = {
          ...defaultVariant,
          currentImage: costume.image_url_shiny,
          variantType: `costume_${costume.costume_id}_shiny` as VariantKind,
        };
        costumeShinyVariant.name = getDisplayName(costumeShinyVariant);
        addVariant(costumeShinyVariant);
      }

      if (costume.shadow_costume && costume.shadow_costume.image_url_shadow_costume) {
        const shadowCostumeVariant: PokemonVariant = {
          ...defaultVariant,
          currentImage: costume.shadow_costume.image_url_shadow_costume,
          variantType: `shadow_costume_${costume.costume_id}` as VariantKind,
        };
        shadowCostumeVariant.name = getDisplayName(shadowCostumeVariant);
        addVariant(shadowCostumeVariant);
      }
    });

    /* ---------- max forms: Dynamax & Gigantamax ---------- */
    pokemon.max?.forEach((mx) => {
      const maxForm = mx as MaxForm;
      if (maxForm.dynamax) {
        const dynamaxVariant: PokemonVariant = {
          ...defaultVariant,
          currentImage: defaultVariant.image_url,
          variantType: 'dynamax',
        };
        dynamaxVariant.name = getDisplayName(dynamaxVariant);
        addVariant(dynamaxVariant);

        if (pokemon.shiny_available) {
          const shinyDynamaxVariant: PokemonVariant = {
            ...defaultVariant,
            currentImage: defaultVariant.image_url_shiny,
            variantType: 'shiny_dynamax',
          };
          shinyDynamaxVariant.name = getDisplayName(shinyDynamaxVariant);
          addVariant(shinyDynamaxVariant);
        }
      }

      if (maxForm.gigantamax) {
        const gigantamaxVariant: PokemonVariant = {
          ...defaultVariant,
          currentImage: maxForm.gigantamax_image_url || defaultVariant.image_url,
          variantType: 'gigantamax',
        };
        gigantamaxVariant.name = getDisplayName(gigantamaxVariant);
        addVariant(gigantamaxVariant);

        if (maxForm.shiny_gigantamax_image_url) {
          const shinyGigantamaxVariant: PokemonVariant = {
            ...defaultVariant,
            currentImage: maxForm.shiny_gigantamax_image_url,
            variantType: 'shiny_gigantamax',
          };
          shinyGigantamaxVariant.name = getDisplayName(shinyGigantamaxVariant);
          addVariant(shinyGigantamaxVariant);
        }
      }
    });

    /* ---------- mega / primal variants ---------- */
    pokemon.megaEvolutions?.forEach((m) => {
      const mega = m as MegaEvolution;
      const suffix = mega.form ? `_${mega.form.toLowerCase()}` : '';
      const base: PokemonVariant = {
        ...defaultVariant,
        attack: mega.attack ?? defaultVariant.attack,
        defense: mega.defense ?? defaultVariant.defense,
        stamina: mega.stamina ?? defaultVariant.stamina,
        image_url: mega.image_url ?? defaultVariant.image_url,
        image_url_shiny: mega.image_url_shiny ?? defaultVariant.image_url_shiny,
        sprite_url: mega.sprite_url ?? defaultVariant.sprite_url,
        primal: mega.primal ?? defaultVariant.primal,
        form: mega.form ?? defaultVariant.form,
        type_1_id: mega.type_1_id,
        type_2_id: mega.type_2_id ?? defaultVariant.type_2_id,
        type_1_icon: getTypeIcon(mega.type1_name),
        type_2_icon: getTypeIcon(mega.type2_name),
        currentImage: mega.image_url || defaultVariant.image_url,
        cp40: mega.cp40 ?? defaultVariant.cp40,
        cp50: mega.cp50 ?? defaultVariant.cp50,
        megaForm: mega.form ?? '',
        variantType: (mega.primal ? 'primal' : `mega${suffix}`) as VariantKind,
      };
      base.name = getDisplayName(base);
      addVariant(base);

      if (mega.image_url_shiny && pokemon.shiny_available) {
        const shinyMegaVariant: PokemonVariant = {
          ...base,
          currentImage: mega.image_url_shiny,
          variantType: (mega.primal ? 'shiny_primal' : `shiny_mega${suffix}`) as VariantKind,
        };
        shinyMegaVariant.name = getDisplayName(shinyMegaVariant);
        addVariant(shinyMegaVariant);
      }
    });

    /* ---------- fusion variants ---------- */
    pokemon.fusion?.forEach((f) => {
      const fusion = f as Fusion;
      if (pokemon.pokemon_id !== fusion.base_pokemon_id1) return;
      const base: PokemonVariant = {
        ...defaultVariant,
        attack: fusion.attack ?? defaultVariant.attack,
        defense: fusion.defense ?? defaultVariant.defense,
        stamina: fusion.stamina ?? defaultVariant.stamina,
        type_1_id: fusion.type_1_id,
        type_2_id: fusion.type_2_id ?? defaultVariant.type_2_id,
        type_1_icon: getTypeIcon(fusion.type1_name),
        type_2_icon: getTypeIcon(fusion.type2_name),
        currentImage: fusion.image_url ?? defaultVariant.image_url,
        fusion_id: fusion.fusion_id,
        variantType: `fusion_${fusion.fusion_id}` as VariantKind,
        species_name: fusion.name,
        name: fusion.name,
      };
      base.name = getDisplayName(base);
      addVariant(base);

      if (fusion.image_url_shiny) {
        const shinyFusionVariant: PokemonVariant = {
          ...base,
          currentImage: fusion.image_url_shiny,
          variantType: `shiny_fusion_${fusion.fusion_id}` as VariantKind,
          name: `${fusion.name}`,
          species_name: fusion.name,
        };
        shinyFusionVariant.name = getDisplayName(shinyFusionVariant);
        addVariant(shinyFusionVariant);
      }
    });

    /* ---------- raid‑boss filter ---------- */
    return variants.map((v) => {
      const raidForms = (pokemon.raid_boss || []).map((rb: RaidBoss) => rb.form);
      if (raidForms.some((f: string) => matchFormsAndVariantType(v.form, f, v.variantType))) {
        return v;
      } else {
        // Remove the raid_boss property if no match, but return the variant
        const { raid_boss, ...rest } = v;
        return rest as PokemonVariant;
      }
    });
  };

  return pokemons.flatMap(generateVariants);
};

export default createPokemonVariants;


--- File: utils\fetchAndProcessVariants.ts ---
// fetchAndProcessVariants.ts

import { getPokemons } from "@/services/pokemonDataService";
import { logSize } from "@/utils/loggers";
import createPokemonVariants from "@/features/variants/utils/createPokemonVariants";
import { determinePokemonKey } from "@/utils/PokemonIDUtils";
import { useImageStore } from '@/stores/useImageStore';
import { putBulkIntoDB } from "@/db/pokemonDB";

const isDev = process.env.NODE_ENV === 'development';

export async function fetchAndProcessVariants() {
  if (isDev) console.log('Fetching new data from API');

  const t0 = Date.now();
  const pokemons = await getPokemons();
  if (isDev) console.log(`Fetched new Pokémon data from API in ${Date.now() - t0} ms`);

  logSize('newly fetched Pokémon data', pokemons); // you can make logSize respect NODE_ENV too if needed

  const t1 = Date.now();
  const variants = createPokemonVariants(pokemons);

  const { preload } = useImageStore.getState();
  variants.forEach(v => {
    v.pokemonKey = determinePokemonKey(v);

    if (v.currentImage) preload(v.currentImage, v.currentImage);
    if (v.type_1_icon) preload(v.type_1_icon, v.type_1_icon);
    if (v.type_2_icon) preload(v.type_2_icon, v.type_2_icon);
  });

  if (isDev) console.log(`Processed Pokémon into variants in ${Date.now() - t1} ms`);

  try {
    const size = new Blob([JSON.stringify(variants)]).size;
    if (isDev) console.log(`Size of processed variants in bytes: ${size}`);
  } catch (err) {
    if (isDev) console.log('Error measuring size of processed variants:', err);
  }

  const t2 = Date.now();
  await putBulkIntoDB('pokemonVariants', variants);
  if (isDev) console.log(`Stored variants in IndexedDB in ${Date.now() - t2} ms`);

  localStorage.setItem('variantsTimestamp', Date.now().toString());
  if (isDev) console.log('Stored updated variants in IndexedDB');

  return variants;
}

--- File: utils\loadVariants.ts ---
// loadVariants.ts
import {
    getAllFromDB,
    getAllPokedexListsFromDB,
    storePokedexListsInIndexedDB,
  } from '@/db/indexedDB';
import sortPokedexLists from './sortPokedexLists';
import { isDataFresh } from '@/utils/cacheHelpers';
import { formatTimeAgo } from '@/utils/formattingHelpers';
import type { PokemonVariant } from '@/types/pokemonVariants';
import type { PokedexLists } from '@/types/pokedex'
import { logSize } from '@/utils/loggers';
import { fetchAndProcessVariants } from './fetchAndProcessVariants';

export async function loadVariants() {
  console.log('Fetching data from API or cache...');

  const variantsTimestamp = parseInt(localStorage.getItem('variantsTimestamp') || '0', 10);
  const pokedexListsTimestamp = parseInt(localStorage.getItem('pokedexListsTimestamp') || '0', 10);

  const variantsFresh = !!variantsTimestamp && isDataFresh(variantsTimestamp);
  const pokedexFresh = !!pokedexListsTimestamp && isDataFresh(pokedexListsTimestamp);

  const logAge = (label: string, t: number) =>
    console.log(t ? `${label} Age: ${formatTimeAgo(t)}` : `${label} data is missing.`);

  logAge('Cached Variants', variantsTimestamp);
  logAge('Cached PokedexLists', pokedexListsTimestamp);

  let variants: PokemonVariant[];
  let pokedexLists: PokedexLists;
  let listsBuiltNow = false;

  if (variantsFresh && pokedexFresh) {
    console.log('Using cached variants and PokedexLists...');
    const t0 = Date.now();
    const [variantsFromDB, pokedexFromDB] = await Promise.all([
      getAllFromDB<PokemonVariant>('pokemonVariants'),   
      getAllPokedexListsFromDB()
    ]);
    const elapsed = Date.now() - t0;

    console.log(`Retrieved both from IndexedDB in ${elapsed} ms`);

    variants = variantsFromDB;
    pokedexLists = pokedexFromDB;
    logSize('cached variants', variants);
    logSize('pokedex lists', pokedexLists);
  } else {
    if (variantsFresh) {
      console.log('Using cached variants');
      const t0 = Date.now();
      variants = await getAllFromDB('pokemonVariants');
      console.log(`Retrieved variants from IndexedDB in ${Date.now() - t0} ms`);
      logSize('cached variants', variants);
    } else {
      console.log('Variants are stale or missing, updating...');
      variants = await fetchAndProcessVariants();
    }

    console.log('PokedexLists are stale or variants updated, regenerating...');
    pokedexLists = sortPokedexLists(variants);
    try {
      await storePokedexListsInIndexedDB(pokedexLists);
      localStorage.setItem('pokedexListsTimestamp', Date.now().toString());
      listsBuiltNow = true;
      console.log('Successfully stored new PokedexLists in PokedexListsDB');
    } catch (error) {
      console.error('Failed to store PokedexLists in PokedexListsDB:', error);
    }

    logSize('new pokedex lists', pokedexLists);
  }

  console.log(`Returning ${variants.length} variants and corresponding pokedex lists.`);
  return { variants, pokedexLists, listsBuiltNow }; // ← ✅ include this new flag
}


--- File: utils\sortPokedexLists.ts ---
// sortPokedexLists.ts

import type { PokemonVariant } from '@/types/pokemonVariants';
import type { PokedexLists } from '@/types/pokedex';

export default function sortPokedexLists(variants: PokemonVariant[]): PokedexLists {
  const lists: PokedexLists = {
    default: [],
    shiny: [],
    costume: [],
    shadow: [],
    'shiny costume': [],
    'shiny shadow': [],
    'shadow costume': [],
    mega: [],
    'shiny mega': [],
    dynamax: [],
    'shiny dynamax': [],
    gigantamax: [],
    'shiny gigantamax': [],
    fusion: [],
    'shiny fusion': []
  };

  variants.forEach((variant: PokemonVariant) => {
    const vt = variant.variantType.toLowerCase();

    if (vt === 'default') {
      lists.default.push(variant);
    } else if (vt === 'shiny') {
      lists.shiny.push(variant);
    } else if (vt.includes('fusion')) {
      if (vt.includes('shiny')) {
        lists['shiny fusion'].push(variant);
      } else {
        lists.fusion.push(variant);
      }
    } else if (vt.includes('gigantamax')) {
      if (vt.includes('shiny')) {
        lists['shiny gigantamax'].push(variant);
      } else {
        lists.gigantamax.push(variant);
      }
    } else if (vt.includes('dynamax')) {
      if (vt.includes('shiny')) {
        lists['shiny dynamax'].push(variant);
      } else {
        lists.dynamax.push(variant);
      }
    } else if (vt.includes('mega') || vt.includes('primal')) {
      if (vt.includes('shiny')) {
        lists['shiny mega'].push(variant);
      } else {
        lists.mega.push(variant);
      }
    } else if (vt.includes('shiny') && vt.includes('costume')) {
      lists['shiny costume'].push(variant);
    } else if (vt.includes('shiny') && vt.includes('shadow')) {
      lists['shiny shadow'].push(variant);
    } else if (vt.includes('shadow') && vt.includes('costume') && !vt.includes('shiny')) {
      lists['shadow costume'].push(variant);
    } else if (vt.includes('costume') && !vt.includes('shiny')) {
      lists.costume.push(variant);
    } else if (vt.includes('shadow') && !vt.includes('shiny')) {
      lists.shadow.push(variant);
    } else {
      lists.default.push(variant);
    }
  });

  return lists;
}
