
--- File: actions\updateInstanceDetails.ts ---
// src/features/instances/actions/updateInstanceDetails.ts

import { produce } from 'immer'; // Add Immer import
import { putBatchedPokemonUpdates } from '@/db/indexedDB';
import type { PokemonInstance } from '@/types/pokemonInstance';
import type { MutableInstances, SetInstancesFn } from '@/types/instances';

type Patch = Partial<PokemonInstance>;
type PatchMap = Record<string, Patch>;

/**
 * Updates fields (e.g., IVs, nickname) on one or more Pok√©mon instances.
 *
 * Overloads:
 * - updater(keyOrKeys: string | string[], patch: Patch): Promise<void>
 * - updater(patchMap: Record<string, Patch>): Promise<void>
 */
export function updateInstanceDetails(
  data: { instances: MutableInstances },
  setData: SetInstancesFn,
): {
  (keyOrKeys: string | string[], patch: Patch): Promise<void>;
  (patchMap: PatchMap): Promise<void>;
} {
  return async (
    keyOrKeysOrMap: string | string[] | PatchMap,
    maybePatch?: Patch,
  ): Promise<void> => {
    const timestamp = Date.now();
    let updatedKeys: string[] = [];

    // Use Immer to create an immutable updated map
    const newMap = produce(data.instances, draft => {
      // Helper to apply a single patch to one key
      const apply = (key: string, patch: Patch) => {
        if (!patch || Object.keys(patch).length === 0) {
          return false; // Return false to indicate no changes
        }

        if (!draft[key]) {
          console.warn(`[updateInstanceDetails] "${key}" missing ‚Äì creating placeholder`);
          draft[key] = {} as Partial<PokemonInstance>;
        }
        draft[key] = {
          ...draft[key],
          ...patch,
          last_update: timestamp,
        };
        return true; // Return true to indicate changes were applied
      };

      const isPatchMap = (
        input: unknown
      ): input is PatchMap =>
        typeof input === 'object' &&
        input !== null &&
        !Array.isArray(input);

      if (isPatchMap(keyOrKeysOrMap) && maybePatch === undefined) {
        // 1) Full per-key map
        const map = keyOrKeysOrMap;
        for (const [key, patch] of Object.entries(map)) {
          if (apply(key, patch)) {
            updatedKeys.push(key); // Only include keys with actual changes
          }
        }
      } else {
        // 2) One shared patch over one or many keys
        const keys =
          typeof keyOrKeysOrMap === 'string'
            ? [keyOrKeysOrMap]
            : Array.isArray(keyOrKeysOrMap)
            ? keyOrKeysOrMap
            : [];

        const patch: Patch = maybePatch ?? {};
        for (const key of keys) {
          if (apply(key, patch)) {
            updatedKeys.push(key); // Only include keys with actual changes
          }
        }
      }
    });

    // Skip further processing if no keys were updated
    if (updatedKeys.length === 0) {
      return;
    }

    // 3) Commit to React state
    setData(prev => ({
      ...prev,
      instances: newMap,
    }));

    // 4) Try service-worker sync
    try {
      const reg = await navigator.serviceWorker.ready;
      reg.active?.postMessage({
        action: 'syncData',
        data: { data: newMap, timestamp },
      });
    } catch (err) {
      console.error('[updateInstanceDetails] SW sync failed:', err);
    }

    // 5) Update local timestamp
    localStorage.setItem('ownershipTimestamp', String(timestamp));

    // 6) Persist to IndexedDB
    for (const key of updatedKeys) {
      try {
        await putBatchedPokemonUpdates(key, newMap[key]);
      } catch (err) {
        console.error(`[updateInstanceDetails] cache fail for ${key}:`, err);
      }
    }

    // 7) Development-only logging
    if (process.env.NODE_ENV === 'development') {
      console.log('[updateInstanceDetails] patches saved', {
        timestamp,
        updatedKeys,
        patches: Object.fromEntries(
          updatedKeys.map(key => [key, newMap[key]])
        ),
      });
    }
  };
}

--- File: actions\updateInstanceStatus.ts ---
// updateInstanceStatus.ts

import { RefObject } from 'react';
import { produce } from 'immer'; // üõ†Ô∏è
import { updatePokemonInstanceStatus } from '../services/updatePokemonInstanceStatus';
import { putBatchedPokemonUpdates } from '@/db/indexedDB';
import type { PokemonInstance } from '@/types/pokemonInstance';
import type { InstanceStatus, Instances } from '@/types/instances';
import { PokemonVariant } from '@/types/pokemonVariants';

type AppState = {
  variants: PokemonVariant[];
  instances: Instances;
};

/**
 * Update one or many Pok√©mon instance status flags (Owned ‚ñ∏ Trade ‚ñ∏ Wanted‚Ä¶).
 */
export const updateInstanceStatus =
  (
    data: AppState,
    setData: (updater: (prev: AppState) => AppState) => AppState,
    instancesDataRef: RefObject<Instances>,
  ) =>
  async (pokemonKeys: string | string[], newStatus: InstanceStatus): Promise<void> => {
    const keys = Array.isArray(pokemonKeys) ? pokemonKeys : [pokemonKeys];
    const timestamp = Date.now();

    // 1) Apply status changes and record which entries actually changed
    const changedKeys = new Set<string>();
    const tempData = produce(instancesDataRef.current, draft => {
      for (const key of keys) {
        const fullKey = updatePokemonInstanceStatus(key, newStatus, data.variants, draft);
        if (!fullKey) continue;

        const original = instancesDataRef.current[fullKey];
        const updated  = draft[fullKey];
        const hasChanges =
          !original ||
          Object.keys(updated).some(
            k => updated[k] !== original[k] || !original.hasOwnProperty(k)
          );

        if (hasChanges) {
          changedKeys.add(fullKey);
        }
      }
    });

    // 2) Commit immediately to React state (and sync our ref)
    setData(prev => ({ ...prev, instances: tempData }));
    instancesDataRef.current = tempData;

    // 3) Prune redundant unowned rows
    const finalData = produce(tempData, draft => {
      for (const key of keys) {
        const entry = draft[key];
        if (
          entry &&
          entry.is_unowned &&
          !entry.is_owned &&
          !entry.is_for_trade &&
          !entry.is_wanted
        ) {
          const basePrefix = key.split('_').slice(0, -1).join('_');
          const hasSibling = Object.keys(draft).some(k => {
            const prefix = k.split('_').slice(0, -1).join('_');
            return prefix === basePrefix && k !== key;
          });
          if (hasSibling) {
            delete draft[key];
          }
        }
      }
    });

    // 4) Commit pruned data
    setData(prev => ({ ...prev, instances: finalData }));
    instancesDataRef.current = finalData;

    // 5) Build a clean, serializable updates map
    const updates = new Map<string, PokemonInstance>();
    for (const fullKey of changedKeys) {
      // Skip any entries that got pruned away
      const updated = finalData[fullKey];
      if (!updated) continue;

      // `updated` is now a plain object‚Äîsafe to spread and store
      updates.set(fullKey, { ...updated, last_update: timestamp });
    }

    // 6) Background sync
    try {
      const reg = await navigator.serviceWorker.ready;
      reg.active?.postMessage({
        action: 'syncData',
        data: { data: finalData, timestamp },
      });
      localStorage.setItem('ownershipTimestamp', timestamp.toString());

      // Write each update; all values here are primitives or plain objects
      for (const [key, value] of updates) {
        try {
          await putBatchedPokemonUpdates(key, value);
        } catch (err) {
          console.error(`[updateInstanceStatus] DB write failed for ${key}:`, err);
        }
      }
    } catch (err) {
      console.error('[updateInstanceStatus] SW / IndexedDB sync failed:', err);
    }
  };


--- File: hooks\useBootstrapInstances.ts ---
// src/features/instances/hooks/useBootstrapInstances.ts

import { useEffect } from 'react';

import { useInstancesStore } from '../store/useInstancesStore';
import { useVariantsStore } from '@/features/variants/store/useVariantsStore';
import { useAuthStore } from '@/stores/useAuthStore';

import { loadInstances } from '../services/loadInstances';
import { checkBatchedUpdates } from '@/stores/BatchedUpdates/checkBatchedUpdates';

/**
 * Hydrates the instance slice the first time variants are ready.
 * Call once at app root (App.tsx or AppProviders.tsx).
 */
export function useBootstrapInstances() {
  const { instancesLoading } = useInstancesStore(state => state);
  const hydrateInstances = useInstancesStore(s => s.hydrateInstances);

  const { variants, variantsLoading } = useVariantsStore();
  const { isLoggedIn } = useAuthStore();

  useEffect(() => {
    if (variantsLoading || !instancesLoading || variants.length === 0) return;

    (async () => {
      try {
        const data = await loadInstances(variants, isLoggedIn);
        hydrateInstances(data);

        if (isLoggedIn) {
          checkBatchedUpdates(useInstancesStore.getState().periodicUpdates);
        }

        useInstancesStore.setState({ instancesLoading: false });
      } catch (err) {
        console.error('[BootstrapInstances] failed:', err);
        useInstancesStore.setState({ instancesLoading: false });
      }
    })();
  }, [variantsLoading, variants, isLoggedIn, instancesLoading, hydrateInstances]);
}

--- File: services\loadInstances.ts ---
// src/features/instances/services/loadInstances.ts

import { getInstancesData, initializeOrUpdateInstancesData } from '../storage/instancesStorage';
import { isDataFresh } from '@/utils/cacheHelpers';
import type { PokemonVariant } from '@/types/pokemonVariants';
import type { Instances } from '@/types/instances';

/**
 * Loads Pok√©mon instances data, either from fresh cache or by initializing/updating.
 *
 * @param variants - Array of Pok√©mon variants to initialize data for.
 * @param isLoggedIn - Whether the user is authenticated.
 * @returns A promise resolving to the instances data.
 */
export async function loadInstances(
  variants: PokemonVariant[],
  isLoggedIn: boolean
): Promise<Instances> {
  try {
    const ts = Number(localStorage.getItem('ownershipTimestamp') || 0);
    const fresh = ts && isDataFresh(ts);

    let data: Instances;
    if (fresh) {
      data = (await getInstancesData()).data;
    } else {
      const keys = variants.map(v => v.pokemonKey).filter(Boolean) as string[];
      data = await initializeOrUpdateInstancesData(keys, variants);
    }

    return data;
  } catch (err) {
    console.error('[loadInstances] Failed to load instances:', err);
    throw err; // Re-throw to allow caller to handle
  }
}

--- File: services\updatePokemonInstanceStatus.ts ---
// updatePokemonInstanceStatus.ts

import { generateUUID, parsePokemonKey } from '@/utils/PokemonIDUtils';
import { createNewInstanceData } from '../utils/createNewInstanceData';
import { updateRegistrationStatus } from '../utils/updateRegistrationStatus';
import type { PokemonVariant } from '@/types/pokemonVariants';
import type { InstanceStatus } from '@/types/instances';
import type { Instances } from '@/types/instances';
import type { PokemonInstance } from '@/types/pokemonInstance';

/* -------------------------------------------------------------------------- */
/*  Public API                                                                */
/* -------------------------------------------------------------------------- */

/**
 * Updates the status flags (owned / wanted / trade‚Ä¶) of a Pok√©mon instance.
 *
 * Returns the instance key that was actually updated (can be a brand‚Äënew UUID)
 * or `null` if the operation was aborted.
 */
export function updatePokemonInstanceStatus(
  pokemonKey: string,
  newStatus: InstanceStatus,
  variants: PokemonVariant[],
  instances: Instances,
): string | null {
  const { baseKey, hasUUID } = parsePokemonKey(pokemonKey);
  const variantData = variants.find((v) => v.pokemonKey === baseKey);

  if (!variantData) {
    console.error('[updatePokemonInstanceStatus] No variant for', baseKey);
    return null;
  }

  console.log('[updatePokemonInstanceStatus] Processing', pokemonKey);

  return hasUUID
    ? handleUuidEntry(pokemonKey, newStatus, instances, baseKey)
    : handleBaseKeyEntry(pokemonKey, newStatus, instances, variantData);
}

/* -------------------------------------------------------------------------- */
/*  Helper logic                                                              */
/* -------------------------------------------------------------------------- */

function handleBaseKeyEntry(
  pokemonKey: string,
  newStatus: InstanceStatus,
  data: Instances,
  variantData: PokemonVariant,
): string {
  let needNew = true;
  let updated = '';

  for (const key of Object.keys(data)) {
    const prefix = key.split('_').slice(0, -1).join('_');
    if (prefix === pokemonKey && data[key].is_unowned && !data[key].is_wanted) {
      applyStatus(key, newStatus, data, pokemonKey);
      updated = key;
      needNew = false;
    }
  }

  if (needNew) {
    const newKey = `${pokemonKey}_${generateUUID()}`;
    data[newKey] = createNewInstanceData(variantData) as PokemonInstance;
    applyStatus(newKey, newStatus, data, pokemonKey);
    updated = newKey;
  }

  return updated;
}

function applyStatus(
  pokemonKey: string,
  newStatus: InstanceStatus,
  data: Instances,
  baseKey: string,
): void {
  const instance = data[pokemonKey];

  // Purified flag only for shadow lines 2301/2302
  if (baseKey.startsWith('2301') || baseKey.startsWith('2302')) {
    instance.purified = baseKey.toLowerCase().includes('default');
  }

  instance.dynamax = baseKey.toLowerCase().includes('dynamax');
  instance.gigantamax = baseKey.toLowerCase().includes('gigantamax');

  if (['Trade', 'Wanted'].includes(newStatus)) {
    if (
      instance.lucky ||
      instance.shadow ||
      instance.is_mega ||
      instance.mega ||
      [2270, 2271].includes(instance.pokemon_id)
    ) {
      alert(
        `Cannot move ${pokemonKey} to ${newStatus} as it is ${
          instance.lucky
            ? 'lucky'
            : instance.shadow
            ? 'shadow'
            : instance.is_mega || instance.mega
            ? 'mega'
            : 'a fusion Pok√©mon'
        }.`
      );
      console.log('[update] blocked due to special status');
      return;
    }
  }

  instance.is_unowned = newStatus === 'Unowned';
  instance.is_owned = ['Owned', 'Trade'].includes(newStatus);
  instance.is_for_trade = newStatus === 'Trade';
  instance.is_wanted = newStatus === 'Wanted';

  for (const key of Object.keys(data)) {
    const prefix = key.split('_').slice(0, -1).join('_');
    if (prefix === baseKey && key !== pokemonKey) {
      switch (newStatus) {
        case 'Unowned':
          data[key].is_owned = false;
          data[key].is_for_trade = false;
          break;
        case 'Owned':
        case 'Trade':
          data[key].is_unowned = false;
          break;
        case 'Wanted':
          if (data[key].is_owned) instance.is_unowned = false;
          break;
      }
    }
  }

  if (newStatus === 'Trade' && !instance.is_owned) instance.is_owned = true;

  if (newStatus === 'Wanted') {
    const anyOwned = Object.keys(data).some((k) => {
      const prefix = k.split('_').slice(0, -1).join('_');
      return data[k].is_owned && prefix === baseKey;
    });
    instance.is_unowned = !anyOwned;
  }

  instance.registered =
    instance.is_owned ||
    instance.is_for_trade ||
    (instance.is_wanted && !instance.is_unowned);

  updateRegistrationStatus(instance, data);
}

function handleUuidEntry(
  pokemonKey: string,
  newStatus: InstanceStatus,
  data: Instances,
  baseKey: string,
): string {
  const instance = data[pokemonKey];

  // Purified flag only for shadow lines 2301/2302
  if (baseKey.startsWith('2301') || baseKey.startsWith('2302')) {
    instance.purified = baseKey.toLowerCase().includes('default');
  }

  instance.dynamax = baseKey.toLowerCase().includes('dynamax');
  instance.gigantamax = baseKey.toLowerCase().includes('gigantamax');

  if (['Trade', 'Wanted'].includes(newStatus)) {
    if (
      instance.lucky ||
      instance.shadow ||
      instance.is_mega ||
      instance.mega ||
      [2270, 2271].includes(instance.pokemon_id)
    ) {
      alert(
        `Cannot move ${pokemonKey} to ${newStatus} as it is ${
          instance.lucky
            ? 'lucky'
            : instance.shadow
            ? 'shadow'
            : instance.is_mega || instance.mega
            ? 'mega'
            : 'a fusion Pok√©mon'
        }.`
      );
      console.log('[update] blocked due to special status');
      return pokemonKey;
    }
  }

  switch (newStatus) {
    case 'Owned':
      instance.is_owned = true;
      instance.is_for_trade = false;
      instance.is_unowned = false;
      instance.is_wanted = false;
      // Update siblings
      for (const key of Object.keys(data)) {
        const prefix = key.split('_').slice(0, -1).join('_');
        if (prefix === baseKey && key !== pokemonKey) {
          data[key].is_unowned = false;
        }
      }
      break;
    case 'Trade':
      instance.is_owned = true;
      instance.is_for_trade = true;
      instance.is_unowned = false;
      instance.is_wanted = false;
      break;
    case 'Wanted':
      if (instance.is_owned) {
        const basePrefix = pokemonKey.split('_').slice(0, -1).join('_');
        const newKey = `${basePrefix}_${generateUUID()}`;
        instance.is_unowned = false; // Ensure original owned instance has is_unowned: false
        data[newKey] = {
          ...instance,
          is_wanted: true,
          is_owned: false,
          is_for_trade: false,
          is_unowned: false,
          registered: true,
        };
        updateRegistrationStatus(data[newKey], data);
        updateRegistrationStatus(instance, data); // Update registration for original instance
        return newKey;
      } else {
        instance.is_wanted = true;
        const prefix = pokemonKey.split('_').slice(0, -1).join('_');
        const anyOwned = Object.values(data).some(
          (d) => d.is_owned && d.pokemonKey?.startsWith(prefix),
        );
        instance.is_unowned = !anyOwned;
        instance.registered = instance.is_owned || instance.is_for_trade || (instance.is_wanted && !instance.is_unowned);
        return pokemonKey;
      }
    case 'Unowned':
      instance.is_unowned = true;
      instance.is_owned = false;
      instance.is_for_trade = false;
      instance.is_wanted = false;
      break;
  }

  instance.registered =
    instance.is_owned ||
    instance.is_for_trade ||
    (instance.is_wanted && !instance.is_unowned);

  updateRegistrationStatus(instance, data);
  return pokemonKey;
}

--- File: storage\instancesStorage.ts ---
// instancesStorage.ts

import * as idb from '@/db/indexedDB';
import { generateUUID, validateUUID } from '@/utils/PokemonIDUtils';
import { createNewInstanceData } from '../utils/createNewInstanceData';

import type { Instances }   from '@/types/instances';
import type { PokemonInstance } from '@/types/pokemonInstance';
import type { PokemonVariant }  from '@/types/pokemonVariants';

/* -------------------------------------------------------------------------- */
/*  Public API                                                                */
/* -------------------------------------------------------------------------- */

export async function getInstancesData(): Promise<{
  data: Instances;
  timestamp: number;
}> {
  const data = await idb.getAllFromDB('pokemonOwnership');
  const instances: Instances = {};

  (data as PokemonInstance[]).forEach((item) => {
    if (item.instance_id) {
      instances[item.instance_id] = item;
    } else if (process.env.NODE_ENV === 'development') {
      console.warn('[getInstancesData] Skipped item without instance_id:', item);
    }
  });

  const rawTs = parseInt(localStorage.getItem('ownershipTimestamp') || '0', 10);
  const timestamp = rawTs > 0 ? rawTs : 0;

  return { data: instances, timestamp };
}

export async function setInstancesData(payload: {
  data: Instances;
  timestamp: number;
}): Promise<void> {
  await idb.clearStore('pokemonOwnership');

  const t0 = performance.now();
  const items = Object.keys(payload.data).map((instance_id) => ({
    ...payload.data[instance_id],
    instance_id,
  })) as PokemonInstance[];

  await idb.putBulkIntoDB('pokemonOwnership', items);

  if (process.env.NODE_ENV === 'development') {
    console.log(
      `Stored instances into IndexedDB in ${Math.round(performance.now() - t0)} ms`
    );
  }

  localStorage.setItem('ownershipTimestamp', payload.timestamp.toString());
}

export async function initializeOrUpdateInstancesData(
  keys: string[],
  variants: PokemonVariant[],
): Promise<Instances> {
  try {
    const { data: stored } = await getInstancesData();
    if (process.env.NODE_ENV === 'development') {
      console.log('[instancesStorage] Parsed instancesData:', stored);
    }

    let shouldUpdate = false;
    const existingKeys = new Set(
      Object.keys(stored).map((k) => {
        const parts = k.split('_');
        const maybeUUID = parts.pop()!;
        return validateUUID(maybeUUID) ? parts.join('_') : k;
      }),
    );

    const t0 = performance.now();
    variants.forEach((variant, i) => {
      const baseKey = keys[i];
      if (existingKeys.has(baseKey)) return;

      const fullKey = `${baseKey}_${generateUUID()}`;
      const newEntry: PokemonInstance = {
        ...createNewInstanceData(variant),
        instance_id: fullKey,
      };
      stored[fullKey] = newEntry;
      shouldUpdate = true;
    });

    if (process.env.NODE_ENV === 'development') {
      console.log(
        `[instancesStorage] Init/update pass took ${Math.round(performance.now() - t0)} ms`,
      );
    }

    if (shouldUpdate) {
      await setInstancesData({ data: stored, timestamp: Date.now() });
    } else if (process.env.NODE_ENV === 'development') {
      console.log('[instancesStorage] No updates required.');
    }

    return stored;
  } catch (err) {
    if (process.env.NODE_ENV === 'development') {
      console.error('[instancesStorage] Failed:', err);
    }
    throw new Error('Failed to update instances data');
  }
}


--- File: store\useInstancesStore.ts ---
// store/useInstancesStore.ts

import { create } from 'zustand';
import { produce } from 'immer'; // Add Immer import
import { periodicUpdates as periodicFactory } from '@/stores/BatchedUpdates/periodicUpdates';
import { mergeInstancesData } from '@/features/instances/utils/mergeInstancesData';
import { updateInstanceStatus as makeUpdateStatus } from '@/features/instances/actions/updateInstanceStatus';
import { updateInstanceDetails as makeUpdateDetails } from '@/features/instances/actions/updateInstanceDetails';
import { useAuthStore } from '@/stores/useAuthStore';
import { useVariantsStore } from '@/features/variants/store/useVariantsStore';
import type { Instances, MutableInstances, InstanceStatus } from '@/types/instances';
import type { PokemonInstance } from '@/types/pokemonInstance';

type Patch = Partial<PokemonInstance>;
type PatchMap = Record<string, Patch>;

interface InstancesStore {
  instances: Instances;
  foreignInstances: Instances | null;
  instancesLoading: boolean;
  setForeignInstances(data: Instances): void;
  resetForeignInstances(): void;
  resetInstances(): void;
  hydrateInstances(data: Instances): void;
  setInstances(data: Instances): void;
  updateInstanceStatus(pokemonKeys: string | string[], newStatus: InstanceStatus): Promise<void>;
  updateInstanceDetails(keyOrKeysOrMap: string | string[] | PatchMap, patch?: Patch): Promise<void>;
  periodicUpdates(): void;
}

export const useInstancesStore = create<InstancesStore>()((set, get) => {
  const scheduledRef = { current: null as any };
  const timerRef = { current: null as NodeJS.Timeout | null };
  const periodicUpdates = periodicFactory(scheduledRef, timerRef);

  return {
    instances: {},
    foreignInstances: null,
    instancesLoading: true,

    resetInstances() {
      console.log('[InstancesStore] resetInstances()');
      set({ instances: {}, instancesLoading: true });
      localStorage.removeItem('ownershipTimestamp');
    },

    hydrateInstances(data) {
      try {
        if (!data) {
          console.log('[InstancesStore] üíæ No data to hydrate');
          set({ instances: {}, instancesLoading: false });
          return;
        }
        const count = Object.keys(data).length;
        console.log(`[InstancesStore] üíæ Hydrated ${count} instance${count === 1 ? '' : 's'} from cache`);
        set({ instances: data, instancesLoading: false });
      } catch (error) {
        console.error('[InstancesStore] üö® Hydration failed:', error);
        set({ instances: {}, instancesLoading: false }); // Changed from true to false to ensure loading state clears even on error
      }
    },

    setForeignInstances(data) {
      const count = Object.keys(data).length;
      console.log(`[InstancesStore] üåç Set foreignInstances with ${count} items`);
      set({ foreignInstances: data });
    },
    
    resetForeignInstances() {
      console.log('[InstancesStore] üåç Reset foreignInstances');
      set({ foreignInstances: null });
    },

    setInstances(incoming) {
      if (!incoming || !Object.keys(incoming).length) {
        console.log('[InstancesStore] ‚ö†Ô∏è No incoming data ‚Äì skipping set');
        return;
      }
    
      const current = get().instances;
      if (JSON.stringify(current) === JSON.stringify(incoming)) {
        console.log('[InstancesStore] üí§ No changes ‚Äì incoming data matches current');
        return;
      }
    
      const username = useAuthStore.getState().user?.username ?? '';
      const merged = mergeInstancesData(current, incoming, username);
    
      // Make sure timestamp is set before state update
      const timestamp = Date.now().toString();
      localStorage.setItem('ownershipTimestamp', timestamp);
      
      set({ instances: merged });
      console.log(`[InstancesStore] ‚úÖ Updated instances ‚Äì now tracking ${Object.keys(merged).length} Pok√©mon`);
    
      // Fixed template string (changed [] to backticks)
      navigator.serviceWorker.ready
        .then(r =>
          r.active?.postMessage({
            action: 'syncData',
            data: { data: merged, timestamp: Date.now() },
          })
        )
        .catch(console.error);
    },

    async updateInstanceStatus(pokemonKeys, newStatus) {
      console.log(`[InstancesStore] üîÑ Updating status for ${pokemonKeys.length} Pok√©mon to "${newStatus}"`);

      const fn = makeUpdateStatus(
        { get variants() { return useVariantsStore.getState().variants; } } as any,
        updater => {
          const res = updater({
            variants: useVariantsStore.getState().variants,
            instances: get().instances,
          });
          set({ instances: res.instances });
          if (Array.isArray(pokemonKeys)) {
            const after = res.instances;
            for (const k of pokemonKeys) {
              if (k.includes('0583-shiny') || k.includes('0584-shiny')) {
                console.log('[DEBUG inst]', newStatus, k, after[k]);
              }
            }
          }
          if (Array.isArray(pokemonKeys)) {
            const after = res.instances;
            for (const k of pokemonKeys) {
              if (k.includes('0583-shiny') || k.includes('0584-shiny')) {
                const row = after[k];
                if (row) {
                  console.log('[DEBUG flags]', newStatus, k, {
                    owned  : row.is_owned,
                    trade  : row.is_for_trade,
                    wanted : row.is_wanted,
                    unowned: row.is_unowned,
                  });
                }
              }
            }
          }      
          return res;
        },
        { current: get().instances }
      );

      await fn(pokemonKeys, newStatus);
      get().periodicUpdates();
    },

    async updateInstanceDetails(keyOrKeysOrMap, patch) {
      console.log('[InstancesStore] üõ† Updating details for', keyOrKeysOrMap);

      const fn = makeUpdateDetails(
        { instances: get().instances }, // Pass current instances directly
        updater => {
          const res = updater({ instances: get().instances });
          // Use Immer to update state immutably
          set(
            produce(state => {
              state.instances = res.instances;
            })
          );
          return res;
        }
      );

      await fn(keyOrKeysOrMap as any, patch as any);
      get().periodicUpdates();
    },

    periodicUpdates,
  };
});

--- File: utils\createNewInstanceData.ts ---
// createNewInstanceData.ts

import { getKeyParts } from '@/utils/PokemonIDUtils';

import type { PokemonInstance } from '@/types/pokemonInstance';
import type { PokemonVariant  } from '@/types/pokemonVariants';

/**
 * Factory that builds a brand‚Äënew Pok√©mon *instance* object
 * (formerly called ‚Äúownership‚Äù entry).
 */
export function createNewInstanceData(variant: PokemonVariant): PokemonInstance {
  const keyParts       = getKeyParts(variant.pokemonKey);
  const matchedCostume = variant.costumes.find(c => c.name === keyParts.costumeName);
  const costumeId      = matchedCostume ? matchedCostume.costume_id : null;

  return {
    pokemon_id: variant.pokemon_id,
    nickname   : null,
    cp         : null,
    attack_iv  : null,
    defense_iv : null,
    stamina_iv : null,
    shiny      : keyParts.isShiny,
    costume_id : costumeId,
    lucky      : false,
    shadow     : keyParts.isShadow,
    purified   : false,
    fast_move_id     : null,
    charged_move1_id : null,
    charged_move2_id : null,
    weight     : null,
    height     : null,
    gender     : null,
    mirror     : false,
    pref_lucky : false,
    registered : false,
    favorite   : false,
    location_card   : null,
    location_caught : null,
    friendship_level: null,
    date_caught : null,
    date_added  : new Date().toISOString(),
    last_update : Date.now(),

    /* instance‚Äëstatus flags */
    is_unowned   : true,
    is_owned     : false,
    is_for_trade : false,
    is_wanted    : false,

    /* trading meta */
    not_trade_list  : {},
    not_wanted_list : {},
    trade_filters   : {},
    wanted_filters  : {},

    /* misc */
    gps        : null,
    mega       : false,
    mega_form  : null,
    is_mega    : false,
    level      : null,
    fusion     : {},
    is_fused   : null,
    fusion_form: null,
    dynamax    : null,
    gigantamax : null,
    max_attack : null,
    max_guard  : null,
    max_spirit : null,
  };
}


--- File: utils\mergeInstancesData.ts ---
// mergeInstancesData.ts

import type { Instances } from '@/types/instances'; 

export const mergeInstancesData = (
    oldData: Instances,
    newData: Instances,
    username: string
  ): Instances => {
    const mergedData: Instances = {};
    const oldDataProcessed: Record<string, string[]> = {};
  
    const extractPrefix = (key: string): string => {
      const keyParts = key.split('_');
      keyParts.pop();
      return keyParts.join('_');
    };
  
    console.log('[mergeInstancesData] Starting merge process‚Ä¶');

  // Remove entries from oldData that don't match the username
  Object.keys(oldData).forEach(key => {
    const entry = oldData[key];
    if (entry.username && entry.username !== username) {
      delete oldData[key];
    }
  });

  // Remove entries from newData that don't match the username
  Object.keys(newData).forEach(key => {
    const entry = newData[key];
    if (entry.username && entry.username !== username) {
      delete newData[key];
    }
  });

  Object.keys(oldData).forEach(oldKey => {
    const prefix = extractPrefix(oldKey);
    if (!oldDataProcessed[prefix]) {
      mergedData[oldKey] = oldData[oldKey];
    } else {
      const significantOld = oldData[oldKey].is_owned || oldData[oldKey].is_for_trade || oldData[oldKey].is_wanted;
      if (significantOld) {
        mergedData[oldKey] = oldData[oldKey];
      }
    }
  });

  Object.keys(newData).forEach(key => {
    const prefix = extractPrefix(key);
    if (Object.prototype.hasOwnProperty.call(oldData, key)) { // fixed
      const significantNew = newData[key].is_owned || newData[key].is_for_trade || newData[key].is_wanted;
      if (significantNew) {
        mergedData[key] = newData[key];
      } else {
        const newDate = new Date(newData[key].last_update || 0);
        const oldDate = new Date(oldData[key].last_update || 0);
        mergedData[key] = (newDate > oldDate) ? newData[key] : oldData[key];
      }
    } else {
      mergedData[key] = newData[key];
    }

    oldDataProcessed[prefix] = oldDataProcessed[prefix] || [];
    oldDataProcessed[prefix].push(key);
  });

  Object.keys(mergedData).forEach(key => {
    if (key.includes("mega") || key.includes("primal")) {
      const leadingNumbersMatch = key.match(/^\d+/);
      if (leadingNumbersMatch) {
        const leadingNumbers = leadingNumbersMatch[0];
        const relatedNewKeys = Object.keys(newData).filter(newKey => newKey.startsWith(leadingNumbers));

        const isShinyMega = key.includes("shiny_mega");
        const isMegaX = key.toLowerCase().includes("mega_x");
        const isMegaY = key.toLowerCase().includes("mega_y");
        const isPrimal = key.includes("primal");
        const isShinyPrimal = key.includes("shiny_primal");

        const hasRelevantEntryInNew = relatedNewKeys.some(newKey => {
          const entry = newData[newKey];
          if (!entry) return false;
          if (isShinyMega) return entry.mega && entry.shiny;
          if (isMegaX || isMegaY) return entry.mega;
          if (isPrimal) return entry.mega;
          if (isShinyPrimal) return entry.mega && entry.shiny;
          return entry.mega;
        });

        if (hasRelevantEntryInNew && mergedData[key].is_unowned) {
          delete mergedData[key];
        }
      }
    }
  });

  Object.keys(mergedData).forEach(key => {
    if (key.includes("fusion")) {
      const leadingDigitsMatch = key.match(/^(\d+)-/);
      if (!leadingDigitsMatch) return;
      const pokemonId = leadingDigitsMatch[1];

      const fusionIdMatch = key.match(/fusion_(\d+)/);
      if (!fusionIdMatch) return;
      const fusionId = fusionIdMatch[1];

      const isShiny = key.includes("shiny");

      const relatedNewKeys = Object.keys(newData).filter(newKey => {
        return newKey.startsWith(pokemonId) && newKey.includes("shiny") === isShiny;
      });

      const hasOwnedFusionVariant = relatedNewKeys.some(newKey => {
        const entry = newData[newKey];
        if (!entry) return false;
        entry.fusion = entry.fusion || {};
        return entry.fusion[fusionId] === true;
      });

      if (hasOwnedFusionVariant && mergedData[key].is_unowned) {
        delete mergedData[key];
      }
    }
  });

  const finalData: Instances = {};
  const ownedTracker = new Set<string>();
  const wantedTracker = new Set<string>();
  const unownedTracker = new Set<string>();

  Object.keys(mergedData).forEach(key => {
    const prefix = extractPrefix(key);
    const entry = mergedData[key];
    if (entry.is_owned) {
      finalData[key] = entry;
      ownedTracker.add(prefix);
    }
  });

  Object.keys(mergedData).forEach(key => {
    const prefix = extractPrefix(key);
    const entry = mergedData[key];
    if (entry.is_wanted) {
      finalData[key] = entry;
      wantedTracker.add(prefix);
    }
  });

  Object.keys(mergedData).forEach(key => {
    const prefix = extractPrefix(key);
    const entry = mergedData[key];
    if (entry.is_unowned && !ownedTracker.has(prefix) && !wantedTracker.has(prefix) && !unownedTracker.has(prefix)) {
      finalData[key] = entry;
      unownedTracker.add(prefix);
    }
  });

  console.log("Merge process completed.");
  return finalData;
};

--- File: utils\updateRegistrationStatus.ts ---
// updateRegistrationStatus.ts

import { oneWaySharedFormPokemonIDs } from '@/utils/constants';

import type { PokemonInstance }  from '@/types/pokemonInstance';
import type { Instances }    from '@/types/instances';

/**
 * Ensures that all related forms (shared dex‚Äënumbers, shiny/shadow/costume
 * variants) share the same `registered` flag.
 */
export function updateRegistrationStatus(
  instance: PokemonInstance,
  instancesData: Instances,
): void {
  const originalId = instance.pokemon_id;

  // find which shared‚Äëform group this Pok√©mon belongs to
  let sharedGroup: number[] | null = null;
  for (const key in oneWaySharedFormPokemonIDs) {
    const group = oneWaySharedFormPokemonIDs[+key];
    if (group.includes(originalId)) {
      sharedGroup = group;
      break;
    }
  }
  if (!sharedGroup) return;

  /* -------------------------------------------------------------- */
  /* 1) check if *any* matching variant is already registered       */
  /* -------------------------------------------------------------- */
  let anyRegistered = instance.registered;

  Object.values(instancesData).forEach((other) => {
    if (other === instance) return;
    if (!sharedGroup!.includes(other.pokemon_id)) return;

    const sameShiny    = other.shiny    === instance.shiny;
    const sameShadow   = other.shadow   === instance.shadow;
    const sameCostume  = other.costume_id === instance.costume_id;

    if (sameShiny && sameShadow && sameCostume && other.registered) {
      anyRegistered = true;
    }
  });

  /* -------------------------------------------------------------- */
  /* 2) propagate the flag to all matching variants                 */
  /* -------------------------------------------------------------- */
  if (anyRegistered) {
    instance.registered = true;
    Object.values(instancesData).forEach((other) => {
      if (other === instance) return;
      if (!sharedGroup!.includes(other.pokemon_id)) return;

      const sameShiny   = other.shiny   === instance.shiny;
      const sameShadow  = other.shadow  === instance.shadow;
      const sameCostume = other.costume_id === instance.costume_id;

      if (sameShiny && sameShadow && sameCostume) {
        other.registered = true;
      }
    });
  }
}
