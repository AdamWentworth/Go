Below is a list of areas and techniques you could investigate to improve the performance of your autocomplete queries:

Indexing Strategies:
Trigram Indexes: PostgreSQL trigram indices (pg_trgm) can speed up ILIKE queries significantly, especially for substring matches.
GIN or GIST Indexes: For unaccented searches, consider using a functional index on unaccent(name) and similar fields. GIN or GIST indexes can help with full-text search or trigram matching.

Partial Indexes: If you have very large datasets, partial indexes on commonly searched prefixes or conditions might help.
Full-Text Search:
Full-Text Search Configuration: Instead of using ILIKE with unaccent, consider PostgreSQL's built-in full-text search capabilities.
TSVECTOR Columns: Create a tsvector column for p.name, p.state_or_province, and c.name combined, and index it. Queries using @@ operators on tsvectors can be much faster.
Prefix Matching with Full-Text Search: With proper dictionaries and indexing, full-text search can handle multi-token queries efficiently.

Caching and Rate-Limiting:
Client-Side Caching: Cache results client-side for repeated partial queries (e.g., Van, Vanc, Vanco), so that each keystroke doesn't force a new database query.
Server-Side Caching (Redis or Memory Cache): Cache recent results in memory (with a short TTL) to handle repeated queries efficiently.
Debouncing and Throttling: Only send queries after a short pause in typing, reducing the load on the server.

Query Optimization:
Reduce the Number of Fields in SELECT: Return only the fields necessary for autocomplete suggestions. Reducing the column count can speed up I/O.
Adjust the LIMIT: If you always only need the top 10 results, ensure no unnecessary sorting or complex ordering is done beyond what’s needed.
Use More Selective Conditions: The current substring matches (%token%) can be expensive. Consider more selective matching logic or ranking results more explicitly and applying indexes suited for that.

Database Maintenance and Configuration:
Proper Vacuuming and Analyze: Ensure the database statistics are up-to-date (VACUUM ANALYZE) so the query planner can choose the most efficient plans.
Work_mem and Shared Buffers Tuning: Adjust PostgreSQL configuration parameters to ensure queries get enough memory for sorting and indexing operations.
Hardware and Scaling: If the load is heavy, consider scaling the hardware or using read replicas to handle more queries in parallel.

Specialized Search Engines:
ElasticSearch, OpenSearch, or Solr: Offload complex substring and full-text searches to a dedicated search engine. They are built for fast autocomplete and fuzzy matching.
Meilisearch or Typesense: Lightweight search engines that provide instant results and easy indexing with prefix and substring matching.

Preprocessing and Denormalization:
Maintain a Precomputed Autocomplete Table: For frequently searched terms, consider maintaining a smaller table indexed specifically for autocomplete queries. This might involve periodic batch updates.
Denormalize Data Fields: Store a combined searchable field (name || ' ' || state_or_province || ' ' || country) with indexes for quick searching.

By exploring these areas—indexes, full-text search, caching, hardware configuration, and potentially external search solutions—you can systematically improve the efficiency and speed of your autocomplete queries.