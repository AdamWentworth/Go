name: deploy-users-prod

on:
  workflow_dispatch:
    inputs:
      image_ref:
        description: "Image to deploy: full ref, or just tag (latest / sha-<commit>). Empty defaults to latest."
        required: false
        default: "latest"
        type: string
      deploy_root:
        description: "Absolute path to the Go repo on prod runner"
        required: false
        default: "/media/adam/storage/Code/Go"
        type: string
      service_name:
        description: "Compose service to deploy"
        required: false
        default: "users_service"
        type: string

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy Users To Prod
    runs-on: [self-hosted, linux, x64, prod]
    environment: production
    concurrency:
      group: deploy-users-prod
      cancel-in-progress: false

    steps:
      - name: Sync Deploy Repo
        shell: bash
        run: |
          set -euo pipefail

          DEPLOY_ROOT="${{ inputs.deploy_root }}"
          DEPLOY_REF="${{ github.ref_name }}"

          if [[ ! -d "${DEPLOY_ROOT}/.git" ]]; then
            echo "Deploy root is not a git repo: ${DEPLOY_ROOT}" >&2
            exit 1
          fi

          if ! git -C "${DEPLOY_ROOT}" diff --quiet || ! git -C "${DEPLOY_ROOT}" diff --cached --quiet; then
            echo "Deploy root has local tracked changes: ${DEPLOY_ROOT}" >&2
            git -C "${DEPLOY_ROOT}" status --short || true
            echo "Commit/stash/revert tracked changes before using automated deploy." >&2
            exit 1
          fi

          UNTRACKED_COUNT="$(git -C "${DEPLOY_ROOT}" ls-files --others --exclude-standard | wc -l | tr -d ' ')"
          if [[ "${UNTRACKED_COUNT}" != "0" ]]; then
            echo "Warning: ${UNTRACKED_COUNT} untracked files present in deploy root; continuing."
          fi

          echo "Syncing ${DEPLOY_ROOT} to origin/${DEPLOY_REF}"
          git -C "${DEPLOY_ROOT}" fetch --prune origin
          git -C "${DEPLOY_ROOT}" checkout "${DEPLOY_REF}"
          git -C "${DEPLOY_ROOT}" pull --ff-only origin "${DEPLOY_REF}"

      - name: Preflight Checks
        shell: bash
        run: |
          set -euo pipefail

          DEPLOY_ROOT="${{ inputs.deploy_root }}"
          COMPOSE_FILE="${DEPLOY_ROOT}/reader/users/docker-compose.yml"
          ENV_FILE="${DEPLOY_ROOT}/reader/users/.env"
          KAFKA_NETWORK="kafka_default"

          if [[ ! -d "${DEPLOY_ROOT}" ]]; then
            echo "Deploy root not found: ${DEPLOY_ROOT}" >&2
            exit 1
          fi

          if [[ ! -f "${COMPOSE_FILE}" ]]; then
            echo "Compose file not found: ${COMPOSE_FILE}" >&2
            exit 1
          fi

          if [[ ! -f "${ENV_FILE}" ]]; then
            echo "Env file not found: ${ENV_FILE}" >&2
            exit 1
          fi

          for key in JWT_SECRET DB_USER DB_PASSWORD DB_HOSTNAME DB_PORT DB_NAME; do
            if ! grep -qE "^${key}=" "${ENV_FILE}"; then
              echo "Required env key missing in ${ENV_FILE}: ${key}" >&2
              exit 1
            fi
          done

          if ! docker network inspect "${KAFKA_NETWORK}" >/dev/null 2>&1; then
            echo "External docker network ${KAFKA_NETWORK} not found; creating it now."
            docker network create "${KAFKA_NETWORK}"
          fi

          docker compose -f "${COMPOSE_FILE}" --env-file "${ENV_FILE}" config >/dev/null

      - name: Deploy With Health Check And Rollback
        shell: bash
        run: |
          set -euo pipefail

          DEPLOY_ROOT="${{ inputs.deploy_root }}"
          SERVICE_NAME="${{ inputs.service_name }}"
          IMAGE_REPO="adamwentworth/users_service"
          RAW_IMAGE_INPUT="${{ inputs.image_ref }}"
          TARGET_IMAGE=""
          COMPOSE_FILE="${DEPLOY_ROOT}/reader/users/docker-compose.yml"
          ENV_FILE="${DEPLOY_ROOT}/reader/users/.env"
          CONTAINER_NAME="users_service"
          COMPOSE_PROJECT_NAME="users"

          if [[ -z "${RAW_IMAGE_INPUT}" ]]; then
            TARGET_IMAGE="${IMAGE_REPO}:latest"
          elif [[ "${RAW_IMAGE_INPUT}" == :* ]]; then
            TARGET_IMAGE="${IMAGE_REPO}${RAW_IMAGE_INPUT}"
          elif [[ "${RAW_IMAGE_INPUT}" == */* ]]; then
            TARGET_IMAGE="${RAW_IMAGE_INPUT}"
          else
            TARGET_IMAGE="${IMAGE_REPO}:${RAW_IMAGE_INPUT}"
          fi

          if [[ "${TARGET_IMAGE}" == */* && "${TARGET_IMAGE}" != *:* && "${TARGET_IMAGE}" != *@* ]]; then
            TARGET_IMAGE="${TARGET_IMAGE}:latest"
          fi

          PREVIOUS_IMAGE="$(docker inspect --format '{{.Config.Image}}' "${CONTAINER_NAME}" 2>/dev/null || true)"
          if [[ -n "${PREVIOUS_IMAGE}" ]]; then
            echo "Previous image: ${PREVIOUS_IMAGE}"
          else
            echo "No existing container image found for ${CONTAINER_NAME}; rollback image will be unavailable."
          fi

          echo "Pulling target image: ${TARGET_IMAGE}"
          docker pull "${TARGET_IMAGE}"

          EXISTING_PROJECT="$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.project" }}' "${CONTAINER_NAME}" 2>/dev/null || true)"
          if [[ -n "${EXISTING_PROJECT}" && "${EXISTING_PROJECT}" != "${COMPOSE_PROJECT_NAME}" ]]; then
            echo "Removing existing ${CONTAINER_NAME} from compose project ${EXISTING_PROJECT} before deploy."
            docker rm -f "${CONTAINER_NAME}"
          fi

          echo "Deploying ${SERVICE_NAME} with image ${TARGET_IMAGE}"
          USERS_IMAGE="${TARGET_IMAGE}" docker compose \
            -f "${COMPOSE_FILE}" \
            --env-file "${ENV_FILE}" \
            up -d --no-deps --force-recreate "${SERVICE_NAME}"

          HEALTH_OK=0
          LAST_STATUS="000"
          rm -f /tmp/users_health_body.txt

          for _ in $(seq 1 30); do
            LAST_STATUS="$(curl -sS -o /tmp/users_health_body.txt -w '%{http_code}' \
              http://127.0.0.1:3005/readyz || true)"

            if [[ "${LAST_STATUS}" == "200" ]]; then
              HEALTH_OK=1
              break
            fi

            sleep 2
          done

          if [[ "${HEALTH_OK}" -ne 1 ]]; then
            echo "New deployment failed health checks (last status: ${LAST_STATUS})." >&2
            echo "Last users health response body:" >&2
            cat /tmp/users_health_body.txt 2>/dev/null || true
            echo "Container status:" >&2
            docker ps -a --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}" || true
            echo "Recent container logs:" >&2
            docker logs --tail 200 "${CONTAINER_NAME}" || true

            if [[ -n "${PREVIOUS_IMAGE}" ]]; then
              echo "Rolling back to ${PREVIOUS_IMAGE}"
              USERS_IMAGE="${PREVIOUS_IMAGE}" docker compose \
                -f "${COMPOSE_FILE}" \
                --env-file "${ENV_FILE}" \
                up -d --no-deps --force-recreate "${SERVICE_NAME}"
            else
              echo "Rollback skipped: previous image not found." >&2
              echo "Manual rollback option: deploy adamwentworth/users_service:latest"
            fi
            exit 1
          fi

          rm -f /tmp/users_health_body.txt
          echo "Deployment succeeded."
